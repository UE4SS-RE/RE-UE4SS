# Summary
# This reusable workflow handles building UE4SS with CMake, including setup of dependencies and uploading of artifacts.
# Any future workflows/tasks that require UE4SS to be built should call this reusable workflow to ensure consistency.
name: "Build UE4SS with CMake"
permissions:
  contents: read
on:
  workflow_call:
    inputs:
      build-mode:
        description: 'Which UE4SS Mode to build (e.g., Game__Shipping__Win64)'
        type: string
        required: true
      commit-sha:
        description: 'Commit to build'
        type: string
        required: true
      should-upload-artifact:
        description: 'Should build output be uploaded as an artifact?'
        type: boolean
        default: false
      artifact-retention-days:
        description: 'How many days to retain artifacts'
        type: string
        default: '7'
      enable-caching:
        description: 'Enable build and dependency caching (disable for production releases)'
        type: boolean
        default: true
      use-clang:
        description: 'Use Clang-CL compiler instead of MSVC'
        type: boolean
        default: false
defaults:
  run:
    shell: pwsh
jobs:
  build:
    runs-on: windows-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          submodules: recursive
          token: ${{ secrets.UEPSEUDO_PAT }}
          ref: ${{inputs.commit-sha}}

      # Calculate cache key based on CMakeLists and submodules
      - name: Calculate cache key
        id: cache_key
        run: |
          # Get all CMakeLists.txt and .cmake files and create a combined hash
          $files = Get-ChildItem -Path . -Include "CMakeLists.txt","*.cmake" -Recurse
          $combinedContent = ""
          foreach ($file in $files) {
            # Include file content hash AND path for better cache invalidation
            $combinedContent += (Get-FileHash $file.FullName).Hash
            $combinedContent += $file.FullName
          }

          # Create a hash of the combined content
          $bytes = [System.Text.Encoding]::UTF8.GetBytes($combinedContent)
          $hash = [System.Security.Cryptography.SHA256]::Create()
          $hashBytes = $hash.ComputeHash($bytes)
          $cmakeHash = [System.BitConverter]::ToString($hashBytes).Replace("-", "")

          # Get submodule commits hash
          git submodule status > submodule_status.txt
          $submoduleHash = (Get-FileHash submodule_status.txt).Hash

          # Combine hashes for final cache key (shortened for readability)
          $combinedHash = "$($cmakeHash.Substring(0, 16))-$($submoduleHash.Substring(0, 16))"
          echo "hash=$combinedHash" >> $env:GITHUB_OUTPUT

          # Clean up temp file
          Remove-Item submodule_status.txt

      # Cache for third-party dependencies fetched by CMake
      # NOTE: This caching approach was carefully designed to avoid PatternSleuth (Rust) cache issues
      # The cache key includes CMakeLists.txt hashes which should catch most dependency changes
      # For Rust version changes, the weekly cache invalidation in CI provides a safety net
      # Caching is disabled for production releases to ensure clean builds
      - name: Cache CMake Dependencies
        if: ${{ inputs.enable-caching }}
        uses: actions/cache@v4
        with:
          path: |
            ~/.cmake/packages
            ~/AppData/Local/vcpkg/archives
            ${{ github.workspace }}/build_cmake_${{ inputs.build-mode }}/_deps
            ${{ github.workspace }}/build_cmake_${{ inputs.build-mode }}/ep_downloads
          key: cmake-deps-${{ runner.os }}-${{ steps.cache_key.outputs.hash }}
          restore-keys: |
            cmake-deps-${{ runner.os }}-

      # Use pre-installed VS instead of downloading
      - name: Setup MSVC Developer Command Prompt
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: x64
          vsversion: "2022"

      # Setup Clang-CL if requested
      - name: Setup Clang-CL
        if: ${{ inputs.use-clang == true }}
        run: |
          # LLVM is pre-installed on windows-latest, just need to ensure clang-cl is in PATH
          $llvmPath = "C:\Program Files\LLVM\bin"
          if (Test-Path $llvmPath) {
            Write-Host "Found LLVM at $llvmPath"
            echo "$llvmPath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          } else {
            Write-Host "LLVM not found at expected location, checking if clang-cl is already available..."
            $clangcl = Get-Command clang-cl -ErrorAction SilentlyContinue
            if ($clangcl) {
              Write-Host "clang-cl found at: $($clangcl.Path)"
            } else {
              Write-Host "##[error]clang-cl not found. Please install LLVM or use MSVC."
              exit 1
            }
          }

      - name: Setup CMake
        uses: jwlawson/actions-setup-cmake@v2
        with:
          cmake-version: 'latest'

      - name: Setup Ninja
        uses: seanmiddleditch/gha-setup-ninja@v5

      - name: Create build directory name
        id: build_dir
        run: |
          $mode = "${{inputs.build-mode}}"
          $buildDir = "build_cmake_$mode"
          echo "name=$buildDir" >> $env:GITHUB_OUTPUT

      # Cache the build directory for incremental builds
      # Disabled for production releases to ensure clean builds
      - name: Cache CMake build directory
        if: ${{ inputs.enable-caching }}
        uses: actions/cache@v4
        id: cache_build
        with:
          path: |
            ${{ steps.build_dir.outputs.name }}
            !${{ steps.build_dir.outputs.name }}/_deps
            !${{ steps.build_dir.outputs.name }}/ep_downloads
          key: cmake-build-${{ inputs.build-mode }}-${{ steps.cache_key.outputs.hash }}-${{ github.run_number }}
          restore-keys: |
            cmake-build-${{ inputs.build-mode }}-${{ steps.cache_key.outputs.hash }}-

      - name: Configure CMake
        run: |
          $needs_reconfigure = $false

          # Check if caching is enabled
          if ("${{ inputs.enable-caching }}" -eq "true") {
            if ("${{ steps.cache_build.outputs.cache-hit }}" -ne "true") {
              Write-Host "Cache miss - full configure needed"
              $needs_reconfigure = $true
            } elseif (-not (Test-Path "${{ steps.build_dir.outputs.name }}/CMakeCache.txt")) {
              Write-Host "No CMakeCache.txt - full configure needed"
              $needs_reconfigure = $true
            }
          } else {
            Write-Host "Caching disabled - clean build required"
            $needs_reconfigure = $true
          }

          if ($needs_reconfigure) {
            # Set environment variables for FetchContent to use a persistent location
            $env:FETCHCONTENT_BASE_DIR = "${{ steps.build_dir.outputs.name }}/_deps"

            # Select compiler based on use-clang parameter
            if ("${{ inputs.use-clang }}" -eq "true") {
              Write-Host "Configuring with Clang-CL compiler"
              $c_compiler = "clang-cl"
              $cxx_compiler = "clang-cl"
            } else {
              Write-Host "Configuring with MSVC compiler"
              $c_compiler = "cl"
              $cxx_compiler = "cl"
            }

            # Configure with incremental linking disabled
            cmake -B ${{ steps.build_dir.outputs.name }} `
              -G Ninja `
              -DCMAKE_BUILD_TYPE="${{inputs.build-mode}}" `
              -DCMAKE_C_COMPILER=$c_compiler `
              -DCMAKE_CXX_COMPILER=$cxx_compiler `
              -DCMAKE_EXPORT_COMPILE_COMMANDS=ON `
              -DCMAKE_EXE_LINKER_FLAGS="/INCREMENTAL:NO" `
              -DCMAKE_MODULE_LINKER_FLAGS="/INCREMENTAL:NO" `
              -DCMAKE_SHARED_LINKER_FLAGS="/INCREMENTAL:NO" `
              -DFETCHCONTENT_QUIET=OFF `
              -DFETCHCONTENT_FULLY_DISCONNECTED=OFF `
              -DFETCHCONTENT_UPDATES_DISCONNECTED=ON
          } else {
            Write-Host "Using cached configuration - incremental build"
            # Just run cmake to ensure cache is valid
            cmake ${{ steps.build_dir.outputs.name }}
          }

      # Build ALL targets with verbose output to see what's happening
      - name: Build All Targets
        run: |
          Write-Host "Building all targets with verbose output..."
          # Build everything with verbose output to see compile/link flags
          cmake --build ${{ steps.build_dir.outputs.name }} --verbose

      # Detect changed files to determine what artifacts to collect
      - name: Detect Changed Files
        id: detect-changes
        if: ${{inputs.should-upload-artifact == true}}
        shell: bash
        run: |
          # Get list of changed files (for PRs, compare against base branch)
          if [ -n "${{ github.event.pull_request.base.sha }}" ]; then
            CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ inputs.commit-sha }})
          else
            # For non-PR runs, just include everything
            CHANGED_FILES=$(git ls-files)
          fi

          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Check if UVTD folder was affected
          if echo "$CHANGED_FILES" | grep -q "^UVTD/"; then
            echo "include_uvtd=true" >> $GITHUB_OUTPUT
          else
            echo "include_uvtd=false" >> $GITHUB_OUTPUT
          fi

          # Check if UE4SS code was affected (excluding docs/assets)
          if echo "$CHANGED_FILES" | grep -qv -E "^(docs|assets|README|LICENSE|\.github)/"; then
            echo "include_ue4ss=true" >> $GITHUB_OUTPUT
          else
            echo "include_ue4ss=false" >> $GITHUB_OUTPUT
          fi

      # Collect selective artifacts based on what changed
      - name: Calculate Files For Artifact Inclusion
        id: calc-files-artifact
        if: ${{inputs.should-upload-artifact == true}}
        run: |
          $artifact_dir = New-Item -Path '${{runner.temp}}/ue4ss_artifacts/' -ItemType Directory -Force
          $buildDir = "${{ steps.build_dir.outputs.name }}"

          $includeUE4SS = "${{ steps.detect-changes.outputs.include_ue4ss }}" -eq "true"
          $includeUVTD = "${{ steps.detect-changes.outputs.include_uvtd }}" -eq "true"

          Write-Host "Collecting selective artifacts from $buildDir..."
          Write-Host "Include UE4SS: $includeUE4SS"
          Write-Host "Include UVTD: $includeUVTD"

          # Collect UE4SS.dll and dwmapi.dll (proxy)
          if ($includeUE4SS) {
            $ue4ssFiles = Get-ChildItem -Path $buildDir -Recurse -Include "UE4SS.dll","UE4SS.pdb","dwmapi.dll" -ErrorAction SilentlyContinue
            foreach ($file in $ue4ssFiles) {
              if ($file.FullName -notlike "*\_deps\*") {
                Write-Host "✓ Found UE4SS file: $($file.Name)"
                Copy-Item $file.FullName -Destination $artifact_dir -Force
              }
            }
          }

          # Collect UVTD files
          if ($includeUVTD) {
            $uvtdFiles = Get-ChildItem -Path $buildDir -Recurse -Include "UVTD.exe","UVTD.pdb" -ErrorAction SilentlyContinue
            foreach ($file in $uvtdFiles) {
              if ($file.FullName -notlike "*\_deps\*") {
                Write-Host "✓ Found UVTD file: $($file.Name)"
                Copy-Item $file.FullName -Destination $artifact_dir -Force
              }
            }
          }

          # Validate that required files were collected (only check files we expect)
          $missingFiles = @()

          if ($includeUE4SS) {
            $requiredUE4SS = @("dwmapi.dll", "UE4SS.dll")
            foreach ($required in $requiredUE4SS) {
              $found = Get-ChildItem -Path $artifact_dir -Filter $required -ErrorAction SilentlyContinue
              if (-not $found) {
                # Try to find it in the source tree (for proxy dll)
                $sourceFile = Get-ChildItem -Path . -Recurse -Filter $required -ErrorAction SilentlyContinue | Select-Object -First 1
                if ($sourceFile) {
                  Write-Host "✓ Found required file in source: $required"
                  Copy-Item $sourceFile.FullName -Destination $artifact_dir -Force
                } else {
                  Write-Host "❌ ERROR: Required UE4SS file $required not found!"
                  $missingFiles += $required
                }
              }
            }
          }

          if ($includeUVTD) {
            if (-not (Test-Path "$artifact_dir\UVTD.exe")) {
              Write-Host "❌ ERROR: Required UVTD.exe not found!"
              $missingFiles += "UVTD.exe"
            }
          }

          # Summary of collected artifacts
          Write-Host "`n========== Artifact Summary =========="
          $artifacts = Get-ChildItem -Path $artifact_dir -ErrorAction SilentlyContinue
          Write-Host "Total files collected: $($artifacts.Count)"

          if ($artifacts.Count -gt 0) {
            # Group by extension
            $artifacts | Group-Object Extension | ForEach-Object {
              Write-Host "$($_.Name) files: $($_.Count)"
              $_.Group | ForEach-Object { Write-Host "  - $($_.Name)" }
            }
          }

          # Fail if critical files are missing
          if ($missingFiles.Count -gt 0) {
            Write-Host "`n❌ Build failed: Missing critical artifacts:" -ForegroundColor Red
            $missingFiles | ForEach-Object { Write-Host "  - $_" -ForegroundColor Red }
            exit 1
          }

          # Fail if no artifacts were collected at all
          if ($artifacts.Count -eq 0) {
            Write-Host "`n❌ Build failed: No artifacts were collected!" -ForegroundColor Red
            Write-Host "This may indicate a build failure or incorrect artifact paths." -ForegroundColor Red
            exit 1
          }

          echo "artifact_dir=$artifact_dir" >> $env:GITHUB_OUTPUT

      - name: Upload a Build Artifact
        if: ${{inputs.should-upload-artifact == true}}
        uses: actions/upload-artifact@v4
        with:
          name: CMAKE-${{inputs.build-mode}}
          path: ${{ steps.calc-files-artifact.outputs.artifact_dir }}
          retention-days: ${{ inputs.artifact-retention-days }}
          overwrite: true
